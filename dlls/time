		pBoid->pev->nextthink = gpGlobals->time + 0.2;
	pev->nextthink = gpGlobals->time + 0.1;
	if( m_flAlertTime > gpGlobals->time )
		pSquad->m_flAlertTime = gpGlobals->time + 15;
	pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.2;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time;
	if( m_flFakeBlockedTime > gpGlobals->time )
		m_flLastBlockedTime = gpGlobals->time;
	UTIL_TraceLine( pev->origin, pev->origin + gpGlobals->v_forward * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
		m_flLastBlockedTime = gpGlobals->time;
	UTIL_TraceLine( pev->origin + gpGlobals->v_right * 12, pev->origin + gpGlobals->v_right * 12 + gpGlobals->v_forward * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
		m_flLastBlockedTime = gpGlobals->time;
	UTIL_TraceLine( pev->origin - gpGlobals->v_right * 12, pev->origin - gpGlobals->v_right * 12 + gpGlobals->v_forward * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
		m_flLastBlockedTime = gpGlobals->time;
	if( !fBlocked && gpGlobals->time - m_flLastBlockedTime > 6 )
		m_flFakeBlockedTime = gpGlobals->time + RANDOM_LONG( 1, 3 ); 
	pev->nextthink = gpGlobals->time + 0.1;
		pev->velocity = gpGlobals->v_forward * pev->speed;
		UTIL_TraceLine( pev->origin, pev->origin + gpGlobals->v_right * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
		UTIL_TraceLine( pev->origin, pev->origin - gpGlobals->v_right * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
	pev->velocity = gpGlobals->v_forward * pev->speed;
	UTIL_TraceLine( pev->origin, pev->origin - gpGlobals->v_up * 16, ignore_monsters, ENT( pev ), &tr );
	if( m_flFlockNextSoundTime < gpGlobals->time )
		m_flFlockNextSoundTime = gpGlobals->time + RANDOM_FLOAT( 1, 3 );
	pev->nextthink = gpGlobals->time + 0.1;
			UTIL_TraceLine( pev->origin, pev->origin + gpGlobals->v_right * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
			UTIL_TraceLine( pev->origin, pev->origin - gpGlobals->v_right * AFLOCK_CHECK_DIST, ignore_monsters, ENT( pev ), &tr );
				m_vecAdjustedVelocity = gpGlobals->v_right;
				m_vecAdjustedVelocity = gpGlobals->v_right * -1;
		if( pev->dmgtime != gpGlobals->time || ( RANDOM_LONG( 0, 10 ) < 1 ) )
			pev->dmgtime = gpGlobals->time;
	m_flNextWordTime = m_flNextSpeakTime = gpGlobals->time + 10 + RANDOM_LONG( 0, 10 );
	if( m_flNextSpeakTime > gpGlobals->time )
			m_flNextSpeakTime = gpGlobals->time + 3;
		if( m_flNextWordTime < gpGlobals->time )
				m_flNextWordTime = gpGlobals->time + RANDOM_FLOAT( 0.5, 1 );
	if( m_flNextPainTime > gpGlobals->time )
	m_flNextPainTime = gpGlobals->time + 0.6;
				vecDirToEnemy = gpGlobals->v_forward;
			pHornet->pev->velocity = gpGlobals->v_forward * 300;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_right * 250;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_right * -250;
	m_flNextSpeakTime = m_flNextWordTime = gpGlobals->time + 10 + RANDOM_LONG( 0, 10 );
	if( gpGlobals->time < m_flNextHornetAttackCheck )
		//UTIL_TraceLine( vecArmPos, vecArmPos + gpGlobals->v_forward * 256, ignore_monsters, ENT( pev ), &tr );
			m_flNextHornetAttackCheck = gpGlobals->time + RANDOM_FLOAT( 2, 5 );
	m_flNextHornetAttackCheck = gpGlobals->time + 0.2;// don't check for half second if this check wasn't successful
			if( BuildRoute( m_vecEnemyLKP - gpGlobals->v_forward * 50, bits_MF_TO_LOCATION, NULL ) )
			UTIL_TraceLine( Center() + gpGlobals->v_forward * 128, m_vecEnemyLKP, ignore_monsters, ENT( pev ), &tr );
				MakeIdealYaw( pev->origin + gpGlobals->v_right * 128 );
				UTIL_TraceLine( Center() - gpGlobals->v_forward * 128, m_vecEnemyLKP, ignore_monsters, ENT( pev ), &tr );
					MakeIdealYaw( pev->origin - gpGlobals->v_right * 128 );
				UTIL_TraceLine( Center() + gpGlobals->v_forward * 256, m_vecEnemyLKP, ignore_monsters, ENT( pev ), &tr );
					MakeIdealYaw( pev->origin + gpGlobals->v_right * 256 );
				UTIL_TraceLine( Center() - gpGlobals->v_forward * 256, m_vecEnemyLKP, ignore_monsters, ENT( pev ), &tr );
					MakeIdealYaw( pev->origin - gpGlobals->v_right * 256 );
			if ( gpGlobals->time >= m_flWaitFinished )
			if ( gpGlobals->time >= m_flWaitFinished )
			if ( m_pCine->m_iDelay <= 0 && gpGlobals->time >= m_pCine->m_startTime )
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
			m_flWaitFinished = gpGlobals->time + pTask->flData;	
			m_flWaitFinished = gpGlobals->time + RANDOM_FLOAT( 0.1, pTask->flData );
			m_flMoveWaitFinished = gpGlobals->time;
			if ( BuildRoute ( m_vecEnemyLKP - gpGlobals->v_forward * 64, bits_MF_TO_LOCATION, NULL ) )
			vec2RightSide = gpGlobals->v_right.Make2D().Normalize();
	pOther->pev->air_finished = gpGlobals->time + 12;
	pev->nextthink = gpGlobals->time + 30;
		flInterval = gpGlobals->time - pev->animtime;
			pev->animtime = gpGlobals->time;
	pev->animtime = gpGlobals->time;
	pev->animtime = gpGlobals->time;
	m_flLastEventCheck = gpGlobals->time;
				PRECACHE_SOUND( (char *)( gpGlobals->pStringBase + ALLOC_STRING( pevent[i].options ) ) );
		pev->nextthink = gpGlobals->time + 1.0;
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		m_flNextRocket = gpGlobals->time + 4.0;
		m_flNextRocket = gpGlobals->time + 15.0;
	pev->nextthink = gpGlobals->time + 0.1;
	if( m_flNextRocket > gpGlobals->time )
		pev->nextthink = gpGlobals->time + 0.2;
			pWreckage->pev->dmgtime = gpGlobals->time + 5;
		pev->nextthink = gpGlobals->time + 0.1;
		m_flNextRocket = gpGlobals->time;
		pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
			m_vecGoal = gpGlobals->v_forward;
			if( m_flLastSeen < gpGlobals->time - 5 )
				m_flPrevSeen = gpGlobals->time;
			m_flLastSeen = gpGlobals->time;
				m_vecGoal = gpGlobals->v_forward;
		if( m_flLastSeen + 90 > gpGlobals->time && DotProduct( ( m_posTarget - pev->origin ).Normalize(), ( m_posDesired - pev->origin ).Normalize() ) > 0.25 )
	// ALERT( at_console, "%.0f %.0f %.0f\n", gpGlobals->time, m_flLastSeen, m_flPrevSeen );
	if( ( m_flLastSeen + 1 > gpGlobals->time ) && ( m_flPrevSeen + 2 < gpGlobals->time ) )
			m_flNextRocket = gpGlobals->time + 10.0;
	Vector vecEst = ( gpGlobals->v_forward * 800 + pev->velocity ).Normalize();
	// ALERT( at_console, "%d %d %d %4.2f\n", pev->angles.x < 0, DotProduct( pev->velocity, gpGlobals->v_forward ) > -100, m_flNextRocket < gpGlobals->time, DotProduct( m_vecTarget, vecEst ) );
		m_flNextRocket = gpGlobals->time + 0.5;
			m_flNextRocket = gpGlobals->time + 10;
	else if( pev->angles.x < 0 && DotProduct( pev->velocity, gpGlobals->v_forward ) > -100 && m_flNextRocket < gpGlobals->time )
		if( m_flLastSeen + 60 > gpGlobals->time )
	// Vector vecEst1 = pev->origin + pev->velocity + gpGlobals->v_up * m_flForce - Vector( 0, 0, 384 );
	// float flSide = DotProduct( m_posDesired - vecEst1, gpGlobals->v_right );
	float flSide = DotProduct( m_vecDesired, gpGlobals->v_right );
	Vector vecEst = pev->origin + pev->velocity * 2.0 + gpGlobals->v_up * m_flForce * 20 - Vector( 0, 0, 384 * 2 );
	pev->velocity.x += gpGlobals->v_up.x * m_flForce;
	pev->velocity.y += gpGlobals->v_up.y * m_flForce;
	pev->velocity.z += gpGlobals->v_up.z * m_flForce;
	float flDir = DotProduct( Vector( gpGlobals->v_forward.x, gpGlobals->v_forward.y, 0 ), Vector( pev->velocity.x, pev->velocity.y, 0 ) );
	float flDist = DotProduct( m_posDesired - vecEst, gpGlobals->v_forward );
	// float flSlip = DotProduct( pev->velocity, gpGlobals->v_right );
	float flSlip = -DotProduct( m_posDesired - vecEst, gpGlobals->v_right );
	pev->velocity.x = pev->velocity.x * ( 1.0 - fabs( gpGlobals->v_right.x ) * 0.05 );
	pev->velocity.y = pev->velocity.y * ( 1.0 - fabs( gpGlobals->v_right.y ) * 0.05 );
	pev->velocity.z = pev->velocity.z * ( 1.0 - fabs( gpGlobals->v_right.z ) * 0.05 );
	Vector vecSrc = pev->origin + 1.5 * ( gpGlobals->v_forward * 21 + gpGlobals->v_right * 70 * side + gpGlobals->v_up * -79 );
		vecSrc = vecSrc + gpGlobals->v_right * 10;
		vecSrc = vecSrc - gpGlobals->v_right * 10;
		vecSrc = vecSrc + gpGlobals->v_up * 10;
		vecSrc = vecSrc - gpGlobals->v_up * 10;
		pRocket->pev->velocity = pev->velocity + gpGlobals->v_forward * 100;
	vecOut.x = DotProduct( gpGlobals->v_forward, vecTarget );
	vecOut.y = -DotProduct( gpGlobals->v_right, vecTarget );
	vecOut.z = DotProduct( gpGlobals->v_up, vecTarget );
		if( flNext < gpGlobals->time )
			flNext = gpGlobals->time + 0.5;
	m_vecForward = gpGlobals->v_forward;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.1;
				m_flKillVictimTime = gpGlobals->time + 10;// now that the victim is in place, the killing bite will be administered in 10 seconds.
			if( m_flKillVictimTime != -1 && gpGlobals->time > m_flKillVictimTime )
			pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 1, 1.5 );	// Stagger a bit to keep barnacles from thinking on the same frame
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		if( gpGlobals->time > m_checkAttackTime )
			m_checkAttackTime = gpGlobals->time + 1;
			m_checkAttackTime = gpGlobals->time + 1.5;
	if( gpGlobals->time < m_painTime )
	m_painTime = gpGlobals->time + RANDOM_FLOAT( 0.5, 0.75 );
		if( m_crabTime < gpGlobals->time && m_crabCount < BIG_MAXCHILDREN )
			pev->velocity = gpGlobals->v_forward * 200 + gpGlobals->v_up * 500;
		if( pev->dmgtime != gpGlobals->time || ( RANDOM_LONG( 0, 10 ) < 1 ) )
			pev->dmgtime = gpGlobals->time;
	else if( gpGlobals->time > m_painSoundTime )
		m_painSoundTime = gpGlobals->time + RANDOM_LONG( 1, 3 );
		m_crabTime = gpGlobals->time + RANDOM_FLOAT( 5, 10 );
		m_crabTime = gpGlobals->time + RANDOM_FLOAT( 0.5, 2.5 );
	m_mortarTime = gpGlobals->time + RANDOM_FLOAT( 2, 15 );
	if( flDist <= BIG_MORTARDIST && m_mortarTime < gpGlobals->time )
		if( m_nodeTime < gpGlobals->time )
		m_nodeTime = gpGlobals->time + pTask->flData;
		m_flWait = gpGlobals->time + GetNodeDelay();
		if( gpGlobals->time > m_flWaitFinished )
	pev->dmgtime = gpGlobals->time + 0.4;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time > pev->dmgtime )
		pev->dmgtime = gpGlobals->time + 0.2;
	pSpit->pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
		m_time = gpGlobals->time;		// Save time to calculate dt
	m_time = gpGlobals->time;
	dt = gpGlobals->time - m_time;	// How much time has passed?
	m_time = gpGlobals->time;		// Remember the last time called
	pev->nextthink = gpGlobals->time + 0.1;
	pSpit->pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time;
	if( gpGlobals->time - m_flLastHurtTime <= 20 )
	if( gpGlobals->time - m_flLastHurtTime < 5 && FClassnameIs( pTarget->pev, "monster_headcrab" ) )
	if( m_hEnemy != NULL && IsMoving() && pevAttacker == m_hEnemy->pev && gpGlobals->time - m_flLastHurtTime > 3 )
		m_flLastHurtTime = gpGlobals->time;
	if( flDist > 64 && flDist <= 784 && flDot >= 0.5 && gpGlobals->time >= m_flNextSpitTime )
			m_flNextSpitTime = gpGlobals->time + 5;
			m_flNextSpitTime = gpGlobals->time + 0.5;
				vecSpitOffset = ( gpGlobals->v_right * 8 + gpGlobals->v_forward * 37 + gpGlobals->v_up * 23 );
					pHurt->pev->velocity = pHurt->pev->velocity - gpGlobals->v_forward * 100;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_up * 100;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_right * 200;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_up * 100;
						pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_forward * 300 + gpGlobals->v_up * 300;
	m_flNextSpitTime = gpGlobals->time;
			gGlobalState.EntityAdd( m_globalstate, gpGlobals->mapname, (GLOBALESTATE)m_initialstate );
		gGlobalState.EntityAdd( m_globalstate, gpGlobals->mapname, newState );
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.5;// no hurry, make sure everything else spawns
	pev->nextthink = gpGlobals->time + 0.1 + RANDOM_FLOAT( 0, 1.5 );// spark again at random interval
		pev->nextthink = gpGlobals->time + 0.5;// no hurry.
	pev->nextthink = gpGlobals->time + 0.1 + RANDOM_FLOAT( 0, 1.5 );
	pev->nextthink = gpGlobals->time + 0.1 + RANDOM_FLOAT( 0, m_flDelay );
	pev->nextthink = gpGlobals->time + 0.1 + RANDOM_FLOAT( 0, m_flDelay );
				else if( !FStrEq( STRING( gpGlobals->mapname ), pGlobal->levelName ) )
				gGlobalState.EntityAdd( pEntity->pev->globalname, gpGlobals->mapname, GLOBAL_ON );
			pEntity->pev->ltime = gpGlobals->time;
				gGlobalState.EntityUpdate( pEntity->pev->globalname, gpGlobals->mapname );
				else if( !FStrEq( STRING( gpGlobals->mapname ), pGlobal->levelName ) )
				gGlobalState.EntityAdd( pEntity->pev->globalname, gpGlobals->mapname, GLOBAL_ON );
	if( gpGlobals->coop || gpGlobals->deathmatch )
	if( pl->m_fNextSuicideTime > gpGlobals->time )
	pl->m_fNextSuicideTime = gpGlobals->time + 1;  // don't let them suicide for 5 seconds after suiciding
	if( player->m_flNextChatTime > gpGlobals->time )
	player->m_flNextChatTime = gpGlobals->time + CHAT_INTERVAL;
					pev->origin + pev->view_ofs + gpGlobals->v_forward * 1000,
	//ALERT( at_console, "PreThink( %g, frametime %g )\n", gpGlobals->time, gpGlobals->frametime );
	//ALERT( at_console, "PostThink( %g, frametime %g )\n", gpGlobals->time, gpGlobals->frametime );
	SAVERESTOREDATA *pSaveData = (SAVERESTOREDATA *)gpGlobals->pSaveData;
	//ALERT( at_console, "SV_Physics( %g, frametime %g )\n", gpGlobals->time, gpGlobals->frametime );
	gpGlobals->teamplay = teamplay.value;
		if( owner >= 1 && owner <= gpGlobals->maxClients )
	pev->animtime = gpGlobals->time;
			pev->nextthink = gpGlobals->time;
	flDot = DotProduct( gpGlobals->v_forward, g_vecAttackDir * -1 );
		UTIL_TraceHull( vecSrc, vecSrc + gpGlobals->v_forward * 64, dont_ignore_monsters, head_hull, edict(), &tr );
		UTIL_TraceHull( vecSrc, vecSrc - gpGlobals->v_forward * 64, dont_ignore_monsters, head_hull, edict(), &tr );
	flDot = DotProduct( gpGlobals->v_forward, g_vecAttackDir * -1 );
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.2;
		pev->nextthink = gpGlobals->time + m_lifeTime;
		pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 10;
		pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 4;
	Vector vecEnd = vecStart + ( gpGlobals->v_forward * flDist );
	flDot = DotProduct( vec2LOS, gpGlobals->v_forward.Make2D() );
	flDot = DotProduct( vec2LOS, gpGlobals->v_forward.Make2D() );
	Vector vecRight = gpGlobals->v_right;
	Vector vecUp = gpGlobals->v_up;
				vecTracerSrc = vecSrc + Vector( 0, 0, -4 ) + gpGlobals->v_right * 2 + gpGlobals->v_forward * 16;
	Vector vecRight = gpGlobals->v_right;
	Vector vecUp = gpGlobals->v_up;
	m_iBallTime[0] = gpGlobals->time + 4.0;
	m_iBallTime[1] = gpGlobals->time + 4.0;
			m_iBallTime[0] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
			m_iBallTime[1] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
			m_flShootTime = gpGlobals->time;
			m_iBallTime[0] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
			m_iBallTime[1] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
			m_iBallTime[0] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
			m_iBallTime[1] = gpGlobals->time + atoi( pEvent->options ) / 15.0;
	float x = DotProduct( gpGlobals->v_forward, m_velocity );
	float y = DotProduct( gpGlobals->v_right, m_velocity );
	float z = DotProduct( gpGlobals->v_up, m_velocity );
	if( m_flShootEnd > gpGlobals->time )
		while( m_flShootTime < m_flShootEnd && m_flShootTime < gpGlobals->time )
			Vector vecSrc = vecHand + pev->velocity * ( m_flShootTime - gpGlobals->time );
				vecSrc = vecSrc + vecDir * ( gpGlobals->time - m_flShootTime );
		float t = m_iBallTime[i] - gpGlobals->time;
	if( m_flMoveWaitFinished > gpGlobals->time )
			pBlocker = CBaseEntity::Instance( gpGlobals->trace_ent );
			if( pBlocker && m_moveWaitTime > 0 && pBlocker->IsMoving() && !pBlocker->IsPlayer() && (gpGlobals->time-m_flMoveWaitFinished) > 3.0 )
					m_flMoveWaitFinished = gpGlobals->time + m_moveWaitTime;
						m_flMoveWaitFinished = gpGlobals->time + m_moveWaitTime * 0.5;
		if( pTarget && pTarget->edict() == gpGlobals->trace_ent )
	pev->nextthink = gpGlobals->time + 0.1;
	pev->dmgtime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time - pev->dmgtime > 5 || pev->renderamt < 64 || m_hEnemy == NULL || m_hOwner == NULL || pev->origin.x < -4096 || pev->origin.x > 4096 || pev->origin.y < -4096 || pev->origin.y > 4096 || pev->origin.z < -4096 || pev->origin.z > 4096 )
		m_flNextAttack = gpGlobals->time + 3.0;
		pev->nextthink = gpGlobals->time + 0.3;
	pev->dmgtime = gpGlobals->time; // keep track of when ball spawned
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time - pev->dmgtime > 5 || pev->velocity.Length() < 10 )
	pev->nextthink = gpGlobals->time + 0.2;
		pev->nextthink = gpGlobals->time;// this will get changed below if the bolt is allowed to stick in what it hit.
			pev->nextthink = gpGlobals->time + 10.0;
			pev->nextthink = gpGlobals->time + 10.0;			
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	Vector vecSrc = m_pPlayer->GetGunPosition() - gpGlobals->v_up * 2;
	Vector vecDir = gpGlobals->v_forward;
	Vector vecSrc	= m_pPlayer->GetGunPosition() - gpGlobals->v_up * 2;
	Vector vecDir	= gpGlobals->v_forward;
		pev->nextthink = gpGlobals->time + 0.1;
	Vector vecEnd = vecSrc + gpGlobals->v_forward * 32;
			pEntity->TraceAttack( m_pPlayer->pev, gSkillData.plrDmgCrowbar, gpGlobals->v_forward, &tr, DMG_CLUB ); 
			pEntity->TraceAttack( m_pPlayer->pev, gSkillData.plrDmgCrowbar / 2, gpGlobals->v_forward, &tr, DMG_CLUB ); 
		int fplaysound = ( pls->sLockedSound && gpGlobals->time > pls->flwaitSound );
		int fplaysentence = ( pls->sLockedSentence && !pls->bEOFLocked && gpGlobals->time > pls->flwaitSentence );
			pls->flwaitSound = gpGlobals->time + flsoundwait;
			pls->flwaitSentence = gpGlobals->time + DOOR_SENTENCEWAIT;
		int fplaysound = ( pls->sUnlockedSound && gpGlobals->time > pls->flwaitSound );
		int fplaysentence = ( pls->sUnlockedSentence && !pls->bEOFUnlocked && gpGlobals->time > pls->flwaitSentence );
			pls->flwaitSound = gpGlobals->time + flsoundwait;
			pls->flwaitSentence = gpGlobals->time + DOOR_SENTENCEWAIT;
				Vector vnext = ( pevActivator->origin + ( gpGlobals->v_forward * 10 ) ) - pev->origin;
		pev->nextthink = gpGlobals->time + 2.0;
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.5;
		pev->nextthink = gpGlobals->time + 2.5 - ( 0.1 * m_frequency );
	pev->dmgtime = gpGlobals->time;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 1.0;
			pev->nextthink = gpGlobals->time;
			pev->dmgtime = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + m_life + RANDOM_FLOAT( 0, m_restrike );
			pev->nextthink = gpGlobals->time + m_life + m_restrike;
			pHit->TraceAttack( pev, pev->dmg * ( gpGlobals->time - pev->dmgtime ), ( ptr->vecEndPos - pev->origin ).Normalize(), ptr, DMG_ENERGYBEAM );
	pev->dmgtime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->dmgtime = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink	= gpGlobals->time + 0.1;
	m_lastTime = gpGlobals->time;
	Animate( pev->framerate * ( gpGlobals->time - m_lastTime ) );
	pev->nextthink = gpGlobals->time + 0.1;
	m_lastTime = gpGlobals->time;
	Animate( pev->framerate * ( gpGlobals->time - m_lastTime ) );
	pev->nextthink = gpGlobals->time + 0.1;
	m_lastTime = gpGlobals->time;
	if( gpGlobals->time > pev->dmgtime )
		pev->nextthink = gpGlobals->time;
	pev->nextthink	= gpGlobals->time;
	m_lastTime = gpGlobals->time;
	float frametime = gpGlobals->time - m_lastTime;
		pev->nextthink = gpGlobals->time + 0.1;
		m_lastTime = gpGlobals->time;
		pev->nextthink = gpGlobals->time;
		m_lastTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + m_flDelay;
	vecShootDir = vecShootDir + gpGlobals->v_right * RANDOM_FLOAT( -1, 1 ) * m_flVariance;;
	vecShootDir = vecShootDir + gpGlobals->v_forward * RANDOM_FLOAT( -1, 1 ) * m_flVariance;;
	vecShootDir = vecShootDir + gpGlobals->v_up * RANDOM_FLOAT( -1, 1 ) * m_flVariance;;
		float thinkTime = pGib->pev->nextthink - gpGlobals->time;
			pGib->pev->nextthink = gpGlobals->time + pGib->m_lifeTime;
			pev->nextthink = gpGlobals->time;
			pev->nextthink = gpGlobals->time;
	float t = gpGlobals->time - m_flStartTime;
		m_flBeamTime[m_iBeam] = gpGlobals->time;
			t = ( gpGlobals->time - m_flBeamTime[i] ) / ( 3 + m_flStartTime - m_flBeamTime[i] );
		pev->nextthink = gpGlobals->time + 0.1;
		m_flStartTime = gpGlobals->time;
		// pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	m_flStartTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
	//pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time;
		pev->dmgtime = gpGlobals->time + ( m_maxFrame / framerate ); 
		pev->nextthink = gpGlobals->time; 
		pev->nextthink = gpGlobals->time + time;
		pev->dmgtime = gpGlobals->time - 1;
	Vector vecAiming = gpGlobals->v_forward;
			m_flAmmoUseTime = gpGlobals->time;// start using ammo ASAP.
			pev->dmgtime = gpGlobals->time + GetPulseInterval();
	Vector tmpSrc = vecOrigSrc + gpGlobals->v_up * -8 + gpGlobals->v_right * 3;
		if( pev->dmgtime < gpGlobals->time )
				if( gpGlobals->time >= m_flAmmoUseTime )
					m_flAmmoUseTime = gpGlobals->time + 0.1;
				if( gpGlobals->time >= m_flAmmoUseTime )
					m_flAmmoUseTime = gpGlobals->time + 0.166;
			pev->dmgtime = gpGlobals->time + GetPulseInterval();
		timedist = ( pev->dmgtime - gpGlobals->time ) / GetPulseInterval();
		if( pev->dmgtime < gpGlobals->time )
				if( gpGlobals->time >= m_flAmmoUseTime )
					m_flAmmoUseTime = gpGlobals->time + 0.2;
				if( gpGlobals->time >= m_flAmmoUseTime )
					m_flAmmoUseTime = gpGlobals->time + 0.1;
			pev->dmgtime = gpGlobals->time + GetDischargeInterval();
			if( m_shakeTime < gpGlobals->time )
				m_shakeTime = gpGlobals->time + 1.5;
		timedist = ( pev->dmgtime - gpGlobals->time ) / GetDischargeInterval();
		m_pBeam->SetColor( 30 + ( 25 * timeBlend ), 30 + ( 30 * timeBlend ), 64 + 80 * fabs( sin( gpGlobals->time * 10 ) ) );
		m_pBeam->SetColor( 60 + ( 25 * timeBlend ), 120 + ( 30 * timeBlend ), 64 + 80 * fabs( sin( gpGlobals->time *10 ) ) );
	m_pSprite->pev->frame += 8 * gpGlobals->frametime;
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.3;
		if( pTarget && pTarget->edict() == gpGlobals->trace_ent )
		pev->angles.z = UTIL_Approach( target, pev->angles.z, 220.0 * gpGlobals->frametime );
	if( flWaypointDist <= 64 + ( m_flGroundSpeed * gpGlobals->frametime ) )
		if( gpGlobals->time - m_stopTime > 1.0 )
			m_flightSpeed = UTIL_Approach( 100, m_flightSpeed, 75 * gpGlobals->frametime );
				m_stopTime = gpGlobals->time;
			m_flightSpeed = UTIL_Approach( 20, m_flightSpeed, 300 * gpGlobals->frametime );
			m_stopTime = gpGlobals->time;
		g_vecAttackDir = gpGlobals->v_forward;
		if( ( gpGlobals->time - m_soundTime ) > 0.7 )
			m_soundTime = gpGlobals->time;
	inline BOOL CanFire( void ) { return (gpGlobals->time - m_lastSightTime) < m_persist; }
	if( gpGlobals->time < m_flNextAttack )
		m_fireLast = gpGlobals->time - ( 1 / m_fireRate ) - 0.01;  // to make sure the gun doesn't fire too many bullets
		m_flNextAttack = gpGlobals->time + ( 1 / m_fireRate );
		m_lastSightTime = gpGlobals->time;
	m_fireLast = gpGlobals->time;
		x * vecSpread.x * gpGlobals->v_right +
		y * vecSpread.y * gpGlobals->v_up;
		// FireBullets needs gpGlobals->v_up, etc.
		int bulletCount = ( gpGlobals->time - m_fireLast ) * m_fireRate;
	if( m_pLaser && (gpGlobals->time > m_laserTime) )
		// TankTrace needs gpGlobals->v_up, etc.
		int bulletCount = ( gpGlobals->time - m_fireLast ) * m_fireRate;
				m_laserTime = gpGlobals->time;
				m_pLaser->pev->dmgtime = gpGlobals->time - 1.0;
		int bulletCount = ( gpGlobals->time - m_fireLast ) * m_fireRate;
		int bulletCount = ( gpGlobals->time - m_fireLast ) * m_fireRate;
			// TankTrace needs gpGlobals->v_up, etc.
	pev->nextthink = gpGlobals->time + 0.3;	// After all the func_tank's have spawned
	if( !gpGlobals->deathmatch )
		if( (int)gpGlobals->deathmatch == 1 )
#define STOMP_FRAMETIME				0.015	// gpGlobals->frametime
	pev->nextthink = gpGlobals->time;
	pev->dmgtime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	while( gpGlobals->time - pev->dmgtime > STOMP_INTERVAL )
				pSprite->pev->nextthink = gpGlobals->time + 0.3;
	Vector vecStart = pev->origin + Vector(0,0,60) + 35 * gpGlobals->v_forward;
			Vector vecEnd = ( gpGlobals->v_forward * GARG_FLAME_LENGTH ) + posGun;
			Vector vecEnd = vecStart + ( gpGlobals->v_forward * GARG_FLAME_LENGTH ); //  - offset[i] * gpGlobals->v_right;
			if( trace.flFraction != 1.0 && gpGlobals->time > m_streakTime )
		m_streakTime = gpGlobals->time;
		m_seeTime = gpGlobals->time + 5;
	m_seeTime = gpGlobals->time + 5;
	m_flameTime = gpGlobals->time + 2;
		if( m_painSoundTime < gpGlobals->time )
			m_painSoundTime = gpGlobals->time + RANDOM_FLOAT( 2.5, 4 );
		if( pev->dmgtime != gpGlobals->time || (RANDOM_LONG( 0, 100 ) < 20 ) )
			pev->dmgtime = gpGlobals->time;
	Vector deathPos = pev->origin + gpGlobals->v_forward * 100;
	pSmoker->pev->nextthink = gpGlobals->time + 2.5;	// Start in 2.5 seconds
	if( gpGlobals->time > m_flameTime )
	if( gpGlobals->time > m_seeTime )
					pHurt->pev->velocity = pHurt->pev->velocity - gpGlobals->v_right * 100;
		m_seeTime = gpGlobals->time + 12;
	Vector vecEnd = vecStart + ( gpGlobals->v_forward * flDist ) - ( gpGlobals->v_up * flDist * 0.3 );
		m_flWaitFinished = gpGlobals->time + pTask->flData;
		m_flameTime = gpGlobals->time + 6;
		m_flWaitFinished = gpGlobals->time + 1.6;
		if( gpGlobals->time > m_flWaitFinished )
			pev->nextthink = gpGlobals->time + 0.15;
				pGib->pev->nextthink = gpGlobals->time + 1.25;
		if( gpGlobals->time > m_flWaitFinished )
			// FlameControls( angles.x + 2 * sin( gpGlobals->time * 8 ), angles.y + 28 * sin( gpGlobals->time * 8.5 ) );
	pev->nextthink = gpGlobals->time;
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.1, 0.2 );
	pev->nextthink = gpGlobals->time;
	float time = gpGlobals->time - pev->dmgtime;
		position = position + gpGlobals->v_forward * radius;
		direction = ( direction + gpGlobals->v_forward ).Normalize();
	pev->nextthink = gpGlobals->time;
	pExplosion->pev->nextthink = gpGlobals->time + time;
		m_pPlayer->m_flStartCharge = gpGlobals->time;
		int pitch = ( gpGlobals->time - m_pPlayer->m_flStartCharge ) * ( 150 / GetFullChargeTime() ) + 100;
		if( m_pPlayer->m_flStartCharge < gpGlobals->time - 10 )
	Vector vecAiming = gpGlobals->v_forward;
	Vector vecSrc = m_pPlayer->GetGunPosition(); // + gpGlobals->v_up * -8 + gpGlobals->v_right * 8;
	if( gpGlobals->time - m_pPlayer->m_flStartCharge > GetFullChargeTime() )
		flDamage = 200 * ( ( gpGlobals->time - m_pPlayer->m_flStartCharge ) / GetFullChargeTime() );
		//ALERT( at_console, "Time:%f Damage:%f\n", gpGlobals->time - m_pPlayer->m_flStartCharge, flDamage );
			m_pPlayer->pev->velocity = m_pPlayer->pev->velocity - gpGlobals->v_forward * flDamage * 5;
	m_pPlayer->m_flPlayAftershock = gpGlobals->time + UTIL_SharedRandomFloat( m_pPlayer->random_seed, 0.3, 0.8 );
	if( m_pPlayer->m_flPlayAftershock && m_pPlayer->m_flPlayAftershock < gpGlobals->time )
	pev->nextthink = gpGlobals->time + 0.3;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 1;
	pev->nextthink = gpGlobals->time + 0.2;
	if( m_flNextAttack < gpGlobals->time && pev->velocity.Length() > 100 )
			pOther->TraceAttack( pevOwner, 1, gpGlobals->v_forward, &tr, DMG_CLUB ); 
		m_flNextAttack = gpGlobals->time + 1.0; // debounce
	pev->nextthink = gpGlobals->time + 0.1;
	if( pev->dmgtime - 1 < gpGlobals->time )
		CSoundEnt::InsertSound( bits_SOUND_DANGER, pev->origin + pev->velocity * ( pev->dmgtime - gpGlobals->time ), 400, 0.1 );
	if( pev->dmgtime <= gpGlobals->time )
	pGrenade->pev->nextthink = gpGlobals->time;
	pGrenade->pev->dmgtime = gpGlobals->time + time;
	pGrenade->pev->nextthink = gpGlobals->time + 0.1;
		pGrenade->pev->nextthink = gpGlobals->time;
		vecAiming = gpGlobals->v_forward;
		if( m_flTalkTime > gpGlobals->time && m_hTalkTarget != NULL )
	m_flTalkTime = gpGlobals->time + duration;
	vecSpot2 = vecSpot2 + gpGlobals->v_right * ( RANDOM_FLOAT( -8, 8 ) + RANDOM_FLOAT( -16, 16 ) );
	vecSpot2 = vecSpot2 + gpGlobals->v_forward * ( RANDOM_FLOAT( -8, 8 ) + RANDOM_FLOAT( -16, 16 ) );
		if( m_flSoundTime <= gpGlobals->time )
			m_flSoundTime = gpGlobals->time + 0.62;
	if( m_flNextCharge >= gpGlobals->time )
		m_flSoundTime = 0.56 + gpGlobals->time;
	if( ( m_iOn == 1 ) && ( m_flSoundTime <= gpGlobals->time ) )
	m_flNextCharge = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 1.0;
	pev->nextthink = gpGlobals->time + 0.1;
		vecSplatDir = vecSplatDir + (RANDOM_FLOAT(-1,1) * 0.6 * gpGlobals->v_right) + (RANDOM_FLOAT(-1,1) * 0.6 * gpGlobals->v_forward);// randomize a bit
	pev->nextthink = gpGlobals->time;// now!
	pev->nextthink = gpGlobals->time + 0.1;
		pev->animtime = gpGlobals->time;
		m_flLastEventCheck = gpGlobals->time;
	pev->nextthink		= gpGlobals->time + 0.1;
	m_lastTime		= gpGlobals->time;
		Animate( pev->framerate * ( gpGlobals->time - m_lastTime ) );
	pev->nextthink = gpGlobals->time + 0.1;
	m_lastTime = gpGlobals->time;
	m_flNextPrimaryAttack = gpGlobals->time + 0.3;
	m_flNextSecondaryAttack = gpGlobals->time + 0.3;
	pev->nextthink = gpGlobals->time + 0.1;
	m_flStartTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.2;
		if( pev->dmgtime < gpGlobals->time )
		else if( RANDOM_FLOAT( 0, pev->dmgtime - m_flStartTime ) > pev->dmgtime - gpGlobals->time )
		pev->nextthink = gpGlobals->time + 0.1;
		m_flStartThrow = gpGlobals->time;
		 m_flReleaseThrow = gpGlobals->time;
		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;
		float time = m_flStartThrow - gpGlobals->time + 3.0;
	if( m_flLastShot + 2 < gpGlobals->time )
	m_flLastShot = gpGlobals->time;
	Vector vecShellVelocity = gpGlobals->v_right * RANDOM_FLOAT( 40, 90 ) + gpGlobals->v_up * RANDOM_FLOAT( 75, 200 ) + gpGlobals->v_forward * RANDOM_FLOAT( -40, 40 );
	EjectBrass( pev->origin + gpGlobals->v_up * 32 + gpGlobals->v_forward * 12, vecShellVelocity, pev->angles.y, m_iShell, TE_BOUNCE_SHELL ); 
			CGrenade::ShootTimed( pev, pev->origin + gpGlobals->v_forward * 34 + Vector( 0, 0, 32 ), m_vecTossVelocity, 2.0 );
			m_flNextGrenadeCheck = gpGlobals->time + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
			m_flNextJump = gpGlobals->time + 3.0;
	if( m_flNextJump < gpGlobals->time && ( flDist <= 128 || HasMemory( bits_MEMORY_BADJUMP ) ) && m_hEnemy != NULL )
	if( m_flNextGrenadeCheck < gpGlobals->time && !HasConditions( bits_COND_ENEMY_OCCLUDED ) && flDist <= 512 /* && flDot >= 0.5 */ /* && NoFriendlyFire() */ )
			if( m_flNextJump > gpGlobals->time )
				vecJumpDir = Vector( gpGlobals->v_forward.x, gpGlobals->v_forward.y, gpGlobals->v_up.z ) * 350;
			m_flNextAttack = gpGlobals->time + 2;
		if( m_flSoundTime <= gpGlobals->time )
			m_flSoundTime = gpGlobals->time + 0.62;
	if( m_flNextCharge >= gpGlobals->time )
		m_flSoundTime = 0.56 + gpGlobals->time;
	if( ( m_iOn == 1 ) && ( m_flSoundTime <= gpGlobals->time ) )
	m_flNextCharge = gpGlobals->time + 0.1;
	if( gpGlobals->time <= CTalkMonster::g_talkWaitTime )
	CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 1.5, 2.0 );
			MySquadLeader()->m_flLastEnemySightTime = gpGlobals->time;
			if( gpGlobals->time - MySquadLeader()->m_flLastEnemySightTime > 5 )
	if( gpGlobals->time < m_flNextGrenadeCheck )
			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.
		m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.
			m_flNextGrenadeCheck = gpGlobals->time; // 1/3 second.
			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.
			m_flNextGrenadeCheck = gpGlobals->time + 0.3; // 1/3 second.
			m_flNextGrenadeCheck = gpGlobals->time + 1; // one full second.
	Vector vecEnd = vecStart + ( gpGlobals->v_forward * 70 );
	Vector vecShellVelocity = gpGlobals->v_right * RANDOM_FLOAT( 40, 90 ) + gpGlobals->v_up * RANDOM_FLOAT( 75, 200 ) + gpGlobals->v_forward * RANDOM_FLOAT( -40, 40 );
	Vector vecShellVelocity = gpGlobals->v_right * RANDOM_FLOAT( 40, 90 ) + gpGlobals->v_up * RANDOM_FLOAT( 75, 200 ) + gpGlobals->v_forward * RANDOM_FLOAT( -40, 40 );
			// CGrenade::ShootTimed( pev, pev->origin + gpGlobals->v_forward * 34 + Vector( 0, 0, 32 ), m_vecTossVelocity, 3.5 );
			m_flNextGrenadeCheck = gpGlobals->time + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
				m_flNextGrenadeCheck = gpGlobals->time + RANDOM_FLOAT( 2, 5 );// wait a random amount of time before shooting again
				m_flNextGrenadeCheck = gpGlobals->time + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
			CGrenade::ShootTimed( pev, pev->origin + gpGlobals->v_forward * 17 - gpGlobals->v_right * 27 + gpGlobals->v_up * 6, g_vecZero, 3 );
				pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_forward * 100 + gpGlobals->v_up * 50;
	m_flNextGrenadeCheck	= gpGlobals->time + 1;
	m_flNextPainTime	= gpGlobals->time;
	if( gpGlobals->time > m_flNextPainTime )
		m_flNextPainTime = gpGlobals->time + 1;
	pBeam->pev->nextthink = gpGlobals->time + -4096.0 * tr.flFraction / pGrunt->pev->velocity.z + 0.5;
		m_flStopAttack = gpGlobals->time + 3.5;
		m_flStopAttack	= gpGlobals->time + 5.0;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 4;
	if( gpGlobals->time > m_flStopAttack )
		pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.1, 0.3 );
			pev->nextthink = gpGlobals->time + 0.1;// fixed think time
			pev->nextthink = gpGlobals->time + 1.0;
			m_flStopAttack = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 1;// stick around long enough for the sound to finish!
	CBaseEntity *pHornet = CBaseEntity::Create( "hornet", m_pPlayer->GetGunPosition( ) + gpGlobals->v_forward * 16 + gpGlobals->v_right * 8 + gpGlobals->v_up * -12, m_pPlayer->pev->v_angle, m_pPlayer->edict() );
	pHornet->pev->velocity = gpGlobals->v_forward * 300;
	m_flRechargeTime = gpGlobals->time + 0.5;
	vecSrc = m_pPlayer->GetGunPosition() + gpGlobals->v_forward * 16 + gpGlobals->v_right * 8 + gpGlobals->v_up * -12;
		vecSrc = vecSrc + gpGlobals->v_up * 8;
		vecSrc = vecSrc + gpGlobals->v_up * 8;
		vecSrc = vecSrc + gpGlobals->v_right * 8;
		vecSrc = vecSrc + gpGlobals->v_right * 8;
		vecSrc = vecSrc + gpGlobals->v_up * -8;
		vecSrc = vecSrc + gpGlobals->v_right * 8;
		vecSrc = vecSrc + gpGlobals->v_up * -8;
		vecSrc = vecSrc + gpGlobals->v_up * -8;
		vecSrc = vecSrc + gpGlobals->v_right * -8;
		vecSrc = vecSrc + gpGlobals->v_right * -8;
		vecSrc = vecSrc + gpGlobals->v_up * 8;
		vecSrc = vecSrc + gpGlobals->v_right * -8;
	pHornet->pev->velocity = gpGlobals->v_forward * 1200;
	m_flRechargeTime = gpGlobals->time + 0.5;
	while( m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] < HORNET_MAX_CARRY && m_flRechargeTime < gpGlobals->time )
				pev->velocity = gpGlobals->v_forward * -200;
					UTIL_TraceHull( pev->origin, pev->origin + gpGlobals->v_forward * -128, dont_ignore_monsters, head_hull, ENT( pev ), &tr );
	if( flDot >= 0.7 && m_flEnemyTouched > gpGlobals->time - 0.2 )
		m_flEnemyTouched = gpGlobals->time;
				if( m_flEnemyTouched < gpGlobals->time - 0.2 && ( m_hEnemy->BodyTarget( pev->origin ) - pev->origin).Length() > ( 32 + 16 + 32 ) )
				if( DotProduct( vecShootDir, gpGlobals->v_forward ) > 0.707 )
					pHurt->pev->velocity = pHurt->pev->velocity - gpGlobals->v_right * 300;
		Vector vecSrc = pev->origin + gpGlobals->v_forward * 32;
			m_flNextAlert = gpGlobals->time + 0.2;
		if( m_flNextAlert < gpGlobals->time )
			m_flNextAlert = gpGlobals->time + RANDOM_FLOAT( 3, 5 );
			if( m_flBlink < gpGlobals->time )
				if( m_flBlink + 0.2 < gpGlobals->time )
					m_flBlink = gpGlobals->time + RANDOM_FLOAT( 3, 4 );
	Vector vecSrc = pev->origin + gpGlobals->v_right * 2 * side;
				Vector vecSrc = pev->origin + gpGlobals->v_forward * 2;
			m_flNextAttack = gpGlobals->time + RANDOM_FLOAT( 0.5, 4.0 );
	if( m_flNextAttack > gpGlobals->time )
	if( m_flNextAttack > gpGlobals->time )
	Vector vecSrc = pev->origin + gpGlobals->v_up * 36 + gpGlobals->v_right * side * 16 + gpGlobals->v_forward * 32;
		Vector vecAim = gpGlobals->v_right * side * RANDOM_FLOAT( 0, 1 ) + gpGlobals->v_up * RANDOM_FLOAT( -1, 1 );
	vecSrc = pev->origin + gpGlobals->v_up * 36;
	vecAim = vecAim + side * gpGlobals->v_right * RANDOM_FLOAT( 0, deflection ) + gpGlobals->v_up * RANDOM_FLOAT( -deflection, deflection );
			if( gpGlobals->trace_ent && gpGlobals->trace_ent == edict() )
	m_stateTime = gpGlobals->time + RANDOM_FLOAT( 1, 5 );
	m_waterTime = gpGlobals->time + RANDOM_FLOAT( 5, 7 );
	m_stateTime = gpGlobals->time + RANDOM_FLOAT( 3, 6 );
			m_stateTime = gpGlobals->time + RANDOM_FLOAT( 18, 25 );
	if( gpGlobals->time > m_attackSoundTime )
		m_attackSoundTime = gpGlobals->time + 0.5;
	vecTest = pev->origin + gpGlobals->v_forward * LEECH_CHECK_DIST;
	if( m_sideTime < gpGlobals->time )
		vecTest = pev->origin + gpGlobals->v_right * LEECH_SIZEX * 2 + gpGlobals->v_forward * LEECH_CHECK_DIST;
		vecTest = pev->origin - gpGlobals->v_right * LEECH_SIZEX * 2 + gpGlobals->v_forward * LEECH_CHECK_DIST;
		m_sideTime = gpGlobals->time + RANDOM_FLOAT( 0.5, 1 );
	pev->nextthink = gpGlobals->time + 0.1;
		m_waterTime = gpGlobals->time + 2;	// Recalc again soon, water may be rising
	m_pb->PointsInit( pev->origin, pev->origin + gpGlobals->v_forward * LEECH_CHECK_DIST );
	m_pt->PointsInit( pev->origin, pev->origin - gpGlobals->v_right * ( pev->avelocity.y * 0.25 ) );
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 1, 1.5 );
		pev->nextthink = gpGlobals->time + 0.1;
	if( m_waterTime < gpGlobals->time )
	if( m_stateTime < gpGlobals->time )
		if( m_zTime < gpGlobals->time )
			m_zTime = gpGlobals->time + RANDOM_FLOAT( 1, 4 );
		pev->velocity = gpGlobals->v_forward * pev->speed;
			vecTest = pev->origin + ( gpGlobals->v_right * LEECH_SIZEX ) + ( gpGlobals->v_forward * LEECH_CHECK_DIST );
			vecTest = pev->origin + ( gpGlobals->v_right * -LEECH_SIZEX ) + ( gpGlobals->v_forward * LEECH_CHECK_DIST );
		pev->velocity = gpGlobals->v_forward * pev->speed;
	sprintf( szVector, "%f", gpGlobals->v_forward.x );
	sprintf( szVector, "%f", gpGlobals->v_forward.y );
	sprintf( szVector, "%f", gpGlobals->v_forward.z );
	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
		pev->nextthink = gpGlobals->time + m_flDelay;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + m_flDelay;
	m_flHungryTime = gpGlobals->time + flFullDuration;
	if( m_flHungryTime > gpGlobals->time )
	pev->nextthink = gpGlobals->time + 0.1;// keep monster thinking.
	flDot = DotProduct( vec2LOS, gpGlobals->v_forward.Make2D() );
			if( pTarget && pTarget->edict() == gpGlobals->trace_ent )
	return gpGlobals->time + flTravelTime;
							//ALERT( at_aiconsole, "Wating for door %.2f\n", m_flMoveWaitFinished-gpGlobals->time );
	if( m_flMoveWaitFinished > gpGlobals->time )
		pBlocker = CBaseEntity::Instance( gpGlobals->trace_ent );
		if( pBlocker && m_moveWaitTime > 0 && pBlocker->IsMoving() && !pBlocker->IsPlayer() && ( gpGlobals->time-m_flMoveWaitFinished ) > 3.0 )
				m_flMoveWaitFinished = gpGlobals->time + m_moveWaitTime;
						if( ( gpGlobals->time - m_flMoveWaitFinished ) < 0.2 )
						m_flMoveWaitFinished = gpGlobals->time + 0.1;
	if( m_flMoveWaitFinished > gpGlobals->time )
	pev->nextthink = gpGlobals->time + 0.1;
		speed = (float)yawSpeed * gpGlobals->frametime * 10;
	// Vector vecSrc = pev->origin + gpGlobals->v_forward * 10;
					+ gpGlobals->v_forward * m_HackedGunPos.y 
					+ gpGlobals->v_right * m_HackedGunPos.x 
					+ gpGlobals->v_up * m_HackedGunPos.z;
		if( m_flMoveWaitFinished > gpGlobals->time )
			ALERT( level, ": Stopped for %.2f. ", m_flMoveWaitFinished - gpGlobals->time );
	vecStepRight = gpGlobals->v_right * COVER_DELTA;
		return gpGlobals->v_forward;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.5;
		pMortar->pev->nextthink = gpGlobals->time + t;
	pev->nextthink = gpGlobals->time + 0.1;
	pMortar->pev->nextthink = gpGlobals->time + time;
					m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16, 
					gpGlobals->v_forward * 800 );
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.5;
	g_VoiceGameMgr.Init( &g_GameMgrHelper, gpGlobals->maxClients );
	g_VoiceGameMgr.Update( gpGlobals->frametime );
		if( m_flIntermissionEndTime < gpGlobals->time )
				|| ( ( g_flIntermissionStartTime + MAX_INTERMISSION_TIME ) < gpGlobals->time ) ) 
	time_remaining = (int)( flTimeLimit ? ( flTimeLimit - gpGlobals->time ) : 0);
	if( flTimeLimit != 0 && gpGlobals->time >= flTimeLimit )
		for( int i = 1; i <= gpGlobals->maxClients; i++ )
	return gpGlobals->coop;
	for( int i = 1; i <= gpGlobals->maxClients; i++ )
	return gpGlobals->time;//now!
		PK->m_flNextDecalTime = gpGlobals->time;
			return gpGlobals->time + 0;		// weapon respawns almost instantly
	return gpGlobals->time + WEAPON_RESPAWN_TIME;
		if( NUMBER_OF_ENTITIES() < ( gpGlobals->maxEntities - ENTITY_INTOLERANCE ) )
	return gpGlobals->time + ITEM_RESPAWN_TIME;
	return gpGlobals->time + AMMO_RESPAWN_TIME;
	m_flIntermissionEndTime = gpGlobals->time + ( (int)mp_chattime.value );
	g_flIntermissionStartTime = gpGlobals->time;
						item->minplayers = min( item->minplayers, gpGlobals->maxClients );
						item->maxplayers = min( item->maxplayers, gpGlobals->maxClients );
	for( int i = 1; i <= gpGlobals->maxClients; i++ )
		strcpy( szNextMap, STRING( gpGlobals->mapname ) );
		strcpy( szFirstMapInList, STRING( gpGlobals->mapname ) );
	pev->nextthink = gpGlobals->time + 0.1;
	if( m_flNextPainSound > gpGlobals->time )
	m_flNextPainSound = gpGlobals->time + RANDOM_FLOAT( 2, 5 );
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		vecDir = vecDir + 2 * gpGlobals->v_up;
		if( DotProduct( vecDir, gpGlobals->v_forward ) < 0 )
		vecDir = vecDir + 2 * gpGlobals->v_forward;
		if( DotProduct( vecDir, gpGlobals->v_right ) > 0 )
		vecDir = vecDir - 2 * gpGlobals->v_right;
		if( DotProduct( vecDir, gpGlobals->v_right ) < 0 )
		vecDir = vecDir + 2 * gpGlobals->v_right;
		pev->nextthink = gpGlobals->time;
	if( m_flShootEnd > gpGlobals->time )
		while( m_flShootTime < m_flShootEnd && m_flShootTime < gpGlobals->time )
				vecSrc = vecHand + pev->velocity * ( m_flShootTime - gpGlobals->time );
				vecSrc = vecSrc + vecDir * ( gpGlobals->time - m_flShootTime );
				vecSrc = vecHand + pev->velocity * ( m_flShootTime - gpGlobals->time );
				vecSrc = vecSrc + vecDir * ( gpGlobals->time - m_flShootTime );
	float flDot = DotProduct( m_vecDesired, gpGlobals->v_forward );
	if( m_flLastSeen + 15 < gpGlobals->time )
		if( m_flLastSeen + 5 > gpGlobals->time && flDist < 256 && flDot > 0 )
	pev->nextthink = gpGlobals->time + 0.1;
			if( m_flLastSeen < gpGlobals->time - 5 )
				m_flPrevSeen = gpGlobals->time;
			m_flLastSeen = gpGlobals->time;
	// Vector vecEst1 = pev->origin + m_velocity + gpGlobals->v_up * m_flForce - Vector( 0, 0, 384 );
	// float flSide = DotProduct( m_posDesired - vecEst1, gpGlobals->v_right );
	float flSide = DotProduct( m_vecDesired, gpGlobals->v_right );
	Vector vecEst = pev->origin + m_velocity * 2.0 + gpGlobals->v_up * m_flForce * 20;
	m_velocity.x += gpGlobals->v_up.x * m_flForce;
	m_velocity.y += gpGlobals->v_up.y * m_flForce;
	m_velocity.z += gpGlobals->v_up.z * m_flForce;
	float flDir = DotProduct( Vector( gpGlobals->v_forward.x, gpGlobals->v_forward.y, 0 ), Vector( m_velocity.x, m_velocity.y, 0 ) );
	float flDist = DotProduct( m_posDesired - vecEst, gpGlobals->v_forward );
	m_velocity.x = m_velocity.x * ( 1.0 - fabs( gpGlobals->v_right.x ) * 0.05 );
	m_velocity.y = m_velocity.y * ( 1.0 - fabs( gpGlobals->v_right.y ) * 0.05 );
	m_velocity.z = m_velocity.z * ( 1.0 - fabs( gpGlobals->v_right.z ) * 0.05 );
			m_flShootTime = gpGlobals->time;
			m_flShootEnd = gpGlobals->time + 1.0;
				m_flShootTime = gpGlobals->time;
				m_flShootEnd = gpGlobals->time + 1.0;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.05;
		pev->nextthink = gpGlobals->time + 0.2;
	pev->nextthink = gpGlobals->time + 0.2;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 1;
	pev->nextthink = gpGlobals->time + 1;
	UTIL_ParticleEffect( pev->origin + gpGlobals->v_forward * 64, g_vecZero, 255, 25 );
	UTIL_ParticleEffect( pev->origin - gpGlobals->v_forward * 64, g_vecZero, 255, 25 );
	UTIL_ParticleEffect( pev->origin + gpGlobals->v_right * 64, g_vecZero, 255, 25 );
	UTIL_ParticleEffect( pev->origin - gpGlobals->v_right * 64, g_vecZero, 255, 25 );
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time;
	strcat( szNrpFilename, STRING( gpGlobals->mapname ) );
	fprintf( file, "Node Graph Report for map:  %s.bsp\n", STRING( gpGlobals->mapname ) );
	WorldGraph.FSaveGraph( (char *)STRING( gpGlobals->mapname ) );
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 1.0;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	m_startTime = gpGlobals->time;
	Vector vecForward = gpGlobals->v_forward;
	Vector vecRight = gpGlobals->v_right;
	Vector vecUp = gpGlobals->v_up;
	pev->nextthink = gpGlobals->time + 0.1;
			pBeam->pev->nextthink = gpGlobals->time + -4096.0 * tr.flFraction / pGrunt->pev->velocity.z + 0.5;
		m_startTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
		m_vel2 = gpGlobals->v_forward * m_pGoalEnt->pev->speed;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time > m_startTime + m_dTime )
	float t = ( gpGlobals->time - m_startTime );
	float flSpeed = DotProduct( gpGlobals->v_forward, m_velocity );
	// float flSpeed = DotProduct( gpGlobals->v_forward, pev->velocity );
	pev->nextthink = gpGlobals->time + 2.0;
	pev->nextthink = gpGlobals->time + 0.1;
	m_startTime = gpGlobals->time + 4.0;
		m_startTime = gpGlobals->time;
		pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	if( m_startTime > gpGlobals->time )
		pev->nextthink = gpGlobals->time + 0.2;
		Vector vecSrc = pev->origin + gpGlobals->v_right * -340;
		Vector vecSrc = pev->origin + gpGlobals->v_right * 340;
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.2;
	if( gpGlobals->time < m_flActivateFinished )
	m_flActivateFinished = gpGlobals->time + 0.5;
	local.x = DotProduct( offset, gpGlobals->v_forward );
	local.y = -DotProduct( offset, gpGlobals->v_right );
	local.z = DotProduct( offset, gpGlobals->v_up );
	pev->nextthink = gpGlobals->time;
	local.x = DotProduct( offset, gpGlobals->v_forward );
	local.y = DotProduct( offset, gpGlobals->v_right );
	local.z = DotProduct( offset, gpGlobals->v_up );
	pevNew->ltime = gpGlobals->time;
	pevNew->nextthink = gpGlobals->time + RANDOM_FLOAT( 10, 20 );
	pWeaponBox->pev->nextthink = gpGlobals->time + 120;
	pev->nextthink = gpGlobals->time + 0.1;
		if( pev->air_finished < gpGlobals->time )
		else if( pev->air_finished < gpGlobals->time + 9 )
		pev->air_finished = gpGlobals->time + AIRTIME;
		if( pev->air_finished < gpGlobals->time )		// drown!
			if( pev->pain_finished < gpGlobals->time )
				pev->pain_finished = gpGlobals->time + 1;
	air = (int)( pev->air_finished - gpGlobals->time );
		if( pev->dmgtime < gpGlobals->time )
		pev->dmgtime = gpGlobals->time + 1;
			m_fDeadTime = gpGlobals->time;
	if( g_pGameRules->IsMultiplayer() && ( gpGlobals->time > ( m_fDeadTime + 6 ) ) && !( m_afPhysicsFlags & PFLAG_OBSERVER ) )
	if( !fAnyButtonDown && !( g_pGameRules->IsMultiplayer() && forcerespawn.value > 0 && ( gpGlobals->time > ( m_fDeadTime + 5 ) ) ) )
			flDot = DotProduct( vecLOS , gpGlobals->v_forward );
	for( int i = 1; i <= gpGlobals->maxClients; i++ )
	Vector vecEnd = vecSrc + ( gpGlobals->v_forward * MAX_ID_RANGE );
				m_flStatusBarDisappearDelay = gpGlobals->time + 1.0;
		else if( m_flStatusBarDisappearDelay > gpGlobals->time )
	if( fabs( gpGlobals->time - m_tbdPrev ) < 2.0 )
	m_tbdPrev = gpGlobals->time;
	if( gpGlobals->time < m_flgeigerDelay )
	m_flgeigerDelay = gpGlobals->time + GEIGERDELAY;
	if( gpGlobals->time >= m_flSuitUpdate && m_flSuitUpdate > 0 )
			m_flSuitUpdate = gpGlobals->time + SUITUPDATETIME;
			if( m_rgflSuitNoRepeatTime[i] < gpGlobals->time )
		m_rgflSuitNoRepeatTime[iempty] = iNoRepeatTime + gpGlobals->time;
	if( m_flSuitUpdate <= gpGlobals->time )
			m_flSuitUpdate = gpGlobals->time + SUITFIRSTUPDATETIME;
			m_flSuitUpdate = gpGlobals->time + SUITUPDATETIME; 
	m_iWeaponVolume -= 250 * gpGlobals->frametime;
		iVolume -= 250 * gpGlobals->frametime;
	if( gpGlobals->time > m_flStopExtraSoundTime )
	m_iWeaponFlash -= 256 * gpGlobals->frametime;
	//gpGlobals->v_forward.z = 0;
	// UTIL_ParticleEffect( pev->origin + gpGlobals->v_forward * iVolume, g_vecZero, 255, 25 );
					gun->m_flNextPrimaryAttack = max( gun->m_flNextPrimaryAttack - gpGlobals->frametime, -1.0 );
					gun->m_flNextSecondaryAttack = max( gun->m_flNextSecondaryAttack - gpGlobals->frametime, -0.001 );
						gun->m_flTimeWeaponIdle = max( gun->m_flTimeWeaponIdle - gpGlobals->frametime, -0.001 );
						gun->pev->fuser1 = max( gun->pev->fuser1 - gpGlobals->frametime, -0.001 );
						gun->m_flPumpTime = max( gun->m_flPumpTime - gpGlobals->frametime, -0.001 );
	m_flNextAttack -= gpGlobals->frametime;
		m_flNextAmmoBurn -= gpGlobals->frametime;
		m_flAmmoStartCharge -= gpGlobals->frametime;
	if( FStringNull( gpGlobals->startspot ) || !strlen(STRING( gpGlobals->startspot ) ) )
		pSpot = UTIL_FindEntityByTargetname( NULL, STRING( gpGlobals->startspot ) );
	pev->air_finished = gpGlobals->time + 12;
	m_flgeigerDelay = gpGlobals->time + 2.0;	// wait a few seconds until user-defined message registrations
	m_flNextChatTime = gpGlobals->time;
	SAVERESTOREDATA *pSaveData = (SAVERESTOREDATA *)gpGlobals->pSaveData;
	pev->nextthink = gpGlobals->time + 0.1;
	UTIL_TraceLine( pev->origin, pev->origin + gpGlobals->v_forward * 128, ignore_monsters, pev->owner, & tr );
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		UTIL_TraceLine( pev->origin, pev->origin + gpGlobals->v_forward * 128, ignore_monsters, pev->owner, & tr );
	pev->nextthink = gpGlobals->time + 0.1;
	UTIL_TraceLine( pMe->pev->origin + pMe->pev->view_ofs,pMe->pev->origin + pMe->pev->view_ofs + gpGlobals->v_forward * 8192,dont_ignore_monsters, pMe->edict(), &tr );
		m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->time;
	m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->time;
		if( gpGlobals->time < m_flNextDecalTime )
		UTIL_TraceLine( pev->origin + pev->view_ofs, pev->origin + pev->view_ofs + gpGlobals->v_forward * 128, ignore_monsters, ENT( pev ), &tr );
			m_flNextDecalTime = gpGlobals->time + decalfrequency.value;
			Create( "monster_human_grunt", pev->origin + gpGlobals->v_forward * 128, pev->angles );
			Vector end = start + gpGlobals->v_forward * 1024;
		UTIL_TraceLine( pev->origin + pev->view_ofs, pev->origin + pev->view_ofs + gpGlobals->v_forward * 128, ignore_monsters, ENT( pev ), &tr );
	if( gpGlobals->time < m_flNextAttack )
	if( gpGlobals->time < m_flNextAttack )
	if( ( m_flFlashLightTime ) && ( m_flFlashLightTime <= gpGlobals->time ) )
				m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->time;
				m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->time;
	if( m_flNextSBarUpdateTime < gpGlobals->time )
		m_flNextSBarUpdateTime = gpGlobals->time + 0.2;
		return gpGlobals->v_forward;
	return gpGlobals->v_forward;
	bestdir = gpGlobals->v_forward;
	for( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )
		if( DotProduct( dir, gpGlobals->v_forward ) < 0 )
		dot = fabs( DotProduct( dir, gpGlobals->v_right ) ) + fabs( DotProduct( dir, gpGlobals->v_up ) ) * 0.5;
			CWeaponBox *pWeaponBox = (CWeaponBox *)CBaseEntity::Create( "weaponbox", pev->origin + gpGlobals->v_forward * 10, pev->angles, edict() );
			pWeaponBox->pev->velocity = gpGlobals->v_forward * 300 + gpGlobals->v_forward * 100;
	pev->nextthink = gpGlobals->time + MessageTime();
		pev->nextthink = gpGlobals->time + nextThink;
	if( !gpGlobals->deathmatch )
	pev->nextthink = gpGlobals->time + 2;// let targets spawn!
	virtual void StartSneaking( void ) { m_tSneaking = gpGlobals->time - 1; }
	virtual void StopSneaking( void ) { m_tSneaking = gpGlobals->time + 30; }
	virtual BOOL IsSneaking( void ) { return m_tSneaking <= gpGlobals->time; }
	pev->nextthink = gpGlobals->time + m_flRespawnTime;
			pev->nextthink = gpGlobals->time + 0.2;
	pev->nextthink = gpGlobals->time + m_flRespawnTime;
		pev->nextthink = gpGlobals->time + m_flRespawnTime;
	if( m_flNextAttack < gpGlobals->time && pev->velocity.Length() > 300 )
			pOther->TraceAttack( pevOwner, dmg, gpGlobals->v_forward, &tr, DMG_CLUB );
		m_flNextAttack = gpGlobals->time + 1.0; // debounce
		pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + m_flRespawnTime;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.2;
		m_flSoundDelay = gpGlobals->time + 1.5;
	if( m_flSoundDelay != 0 && m_flSoundDelay <= gpGlobals->time )
	// ALERT( at_console, "%.2f\n", gpGlobals->time - m_flSoundDelay );
	m_flNextSmellTime = gpGlobals->time;
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 1, 1.5 );
		pev->nextthink = gpGlobals->time + 0.1;// keep monster thinking
		pev->nextthink = gpGlobals->time + 1;
	pev->nextthink = gpGlobals->time + flSuspendTime;
	pev->velocity = gpGlobals->v_forward * 250;
	pev->nextthink = gpGlobals->time + 0.4;
	m_flIgniteTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	vecTarget = gpGlobals->v_forward;
			flDot = DotProduct( gpGlobals->v_forward, vecDir );
	if( gpGlobals->time - m_flIgniteTime < 1.0 )
	pev->nextthink = gpGlobals->time + 0.1;
		Vector vecSrc = m_pPlayer->GetGunPosition() + gpGlobals->v_forward * 16 + gpGlobals->v_right * 8 + gpGlobals->v_up * -8;
		pRocket->pev->velocity = pRocket->pev->velocity + gpGlobals->v_forward * DotProduct( m_pPlayer->pev->velocity, gpGlobals->v_forward );
		Vector vecAiming = gpGlobals->v_forward;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
		Vector vecThrow = gpGlobals->v_forward * 274 + m_pPlayer->pev->velocity;
			if( gpGlobals->time >= m_flWaitFinished )
			if( gpGlobals->time >= m_flWaitFinished )
			if( m_pCine->m_iDelay <= 0 && gpGlobals->time >= m_pCine->m_startTime )
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + pTask->flData;
			m_flWaitFinished = gpGlobals->time + pTask->flData;	
			m_flWaitFinished = gpGlobals->time + RANDOM_FLOAT( 0.1, pTask->flData );
			m_flMoveWaitFinished = gpGlobals->time;
			if( BuildRoute( m_vecEnemyLKP - gpGlobals->v_forward * 64, bits_MF_TO_LOCATION, NULL ) )
			vec2RightSide = gpGlobals->v_right.Make2D().Normalize();
	BOOL DisregardEnemy( CBaseEntity *pEnemy ) { return !pEnemy->IsAlive() || ( gpGlobals->time - m_fearTime ) > 15; }
	if( gpGlobals->time < m_painTime )
	m_painTime = gpGlobals->time + RANDOM_FLOAT( 0.5, 0.75 );
				m_fearTime = gpGlobals->time;
					if( gpGlobals->time - m_fearTime > 3 )	// Only cower every 3 seconds or so
						m_fearTime = gpGlobals->time;		// Update last fear
					m_fearTime = gpGlobals->time;
	if( ( m_healTime > gpGlobals->time ) || ( m_hTargetEnt == NULL ) || ( m_hTargetEnt->pev->health > ( m_hTargetEnt->pev->max_health * 0.5 ) ) )
	m_healTime = gpGlobals->time + 60;
	pev->nextthink = gpGlobals->time + 0.1;
		if( m_flResponseDelay && gpGlobals->time > m_flResponseDelay )
	pev->nextthink = gpGlobals->time + 0.1;
	m_flResponseDelay = gpGlobals->time + RANDOM_FLOAT( 3, 4 );
	CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 4.8, 5.2 );
		CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 4.8, 5.2 );
		CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 4.8, 5.2 );
		pev->nextthink = gpGlobals->time + 1.0;
			m_startTime = gpGlobals->time + 1E6;
		m_startTime = gpGlobals->time + 0.05;
		pev->nextthink = gpGlobals->time;
	entvars_t *pevOther = VARS( gpGlobals->other );
			m_startTime = gpGlobals->time + 1E6;
			m_startTime = gpGlobals->time + 1E6;
		pev->nextthink = gpGlobals->time + 1.0;
		pev->nextthink = gpGlobals->time + 0.1;
					pTarget->m_startTime = gpGlobals->time + 0.05;
	pev->nextthink = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 1.0;
		pev->nextthink = gpGlobals->time + m_flDuration + m_flRepeat;
		pev->nextthink = gpGlobals->time + m_flRepeat + 0.5;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time;
		m_flPumpTime = gpGlobals->time + 0.5;
		m_flPumpTime = gpGlobals->time + 0.95;
	if( m_flPumpTime && m_flPumpTime < gpGlobals->time )
	return gpGlobals->time;//now!
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.2;
				pev->nextthink = gpGlobals->time + 0.1;
				pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.25;
	pev->nextthink = gpGlobals->time + 0.75;
	pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.0, 0.5 ); 
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 5.0, 15.0 );
	if( gpGlobals->time <= CTalkMonster::g_talkWaitTime )
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( ANNOUNCE_MINUTES_MIN * 60.0, ANNOUNCE_MINUTES_MAX * 60.0 );
		CTalkMonster::g_talkWaitTime = gpGlobals->time + 5;		// time delay until it's ok to speak: used so that two NPCs don't talk at once
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 1; 
	pev->nextthink = gpGlobals->time + 0.3;// how often to check the sound list.
		if( m_SoundPool[ iSound ].m_flExpireTime <= gpGlobals->time && m_SoundPool[ iSound ].m_flExpireTime != SOUND_NEVER_EXPIRE )
	pSoundEnt->m_SoundPool[iThisSound].m_flExpireTime = gpGlobals->time + flDuration;
	for( i = 0; i < gpGlobals->maxClients; i++ )
	if( iReturn < 0 || iReturn > gpGlobals->maxClients )
	vecLeftSide = pev->origin - ( gpGlobals->v_right * ( pev->size.x * 1.5 ) );
	vecRightSide = pev->origin + ( gpGlobals->v_right * ( pev->size.x * 1.5 ) );
	v_left = gpGlobals->v_right * -1;
	leftPlane.InitializePlane( gpGlobals->v_right, vecLeftSide );
	backPlane.InitializePlane( gpGlobals->v_forward, pev->origin );
	pev->nextthink = gpGlobals->time + 0.1;
	m_flNextHunt = gpGlobals->time + 1E6;
	m_flDie = gpGlobals->time + SQUEEK_DETONATE_DELAY;
	m_flNextBounceSoundTime = gpGlobals->time;// reset each time a snark is spawned.
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time >= m_flDie )
	if( m_flNextHunt > gpGlobals->time )
	m_flNextHunt = gpGlobals->time + 2.0;
	if( ( m_flDie - gpGlobals->time <= 0.5 ) && ( m_flDie - gpGlobals->time >= 0.3 ) )
	float flpitch = 155.0 - 60.0 * ( ( m_flDie - gpGlobals->time ) / SQUEEK_DETONATE_DELAY );
	if( m_flNextHit > gpGlobals->time )
	flpitch = 155.0 - 60.0 * ( ( m_flDie - gpGlobals->time ) / SQUEEK_DETONATE_DELAY );
	if( pOther->pev->takedamage && m_flNextAttack < gpGlobals->time )
				pOther->TraceAttack( pev, gSkillData.snarkDmgBite, gpGlobals->v_forward, &tr, DMG_SLASH ); 
				m_flNextAttack = gpGlobals->time + 0.5;
	m_flNextHit = gpGlobals->time + 0.1;
	m_flNextHunt = gpGlobals->time;
		if( gpGlobals->time < m_flNextBounceSoundTime )
	m_flNextBounceSoundTime = gpGlobals->time + 0.5;// half second.
	pev->animtime = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 0.1;
		UTIL_TraceLine( trace_origin + gpGlobals->v_forward * 20, trace_origin + gpGlobals->v_forward * 64, dont_ignore_monsters, NULL, &tr );
			pSqueak->pev->velocity = gpGlobals->v_forward * 200 + m_pPlayer->pev->velocity;
	if( gpGlobals->time < gStats.lastGameTime )	// Changed level or died, don't b0rk
		gStats.lastGameTime = gpGlobals->time;
	gStats.gameTime += gpGlobals->time - gStats.lastGameTime;
	gStats.lastGameTime = gpGlobals->time;
		UpdateStatsFile( gStats.dataTime, (char *)STRING( gpGlobals->mapname ), health, ammo, (int)CVAR_GET_FLOAT( "skill" ) );
	gStats.lastGameTime = gpGlobals->time;	// Fixup stats time
		pTemp->pev->nextthink = gpGlobals->time + m_flDelay;
		pev->movedir = gpGlobals->v_forward;
		m_flWaitFinished = gpGlobals->time + pTask->flData;
				m_flMoveWaitFinished = gpGlobals->time + 2;
			if( UTIL_DotPoints( pPlayer->v.origin, pev->origin, gpGlobals->v_forward ) < m_flFieldOfView )
		if( gpGlobals->time > m_flWaitFinished )
				if( gpGlobals->time > m_flWaitFinished && FlYawDiff() < 10 )
			// ALERT( at_console, "waiting %f\n", m_flStopTalkTime - gpGlobals->time );
	if( gpGlobals->time <= CTalkMonster::g_talkWaitTime )
	m_useTime = gpGlobals->time + duration;
	CTalkMonster::g_talkWaitTime = gpGlobals->time + duration + 2.0;
		m_flStopTalkTime = gpGlobals->time + 3;
		m_flStopTalkTime = gpGlobals->time + flDuration;
				//CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 2.8, 3.2 );
				//CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT( 2.8, 3.2 );
						UTIL_DotPoints( pPlayer->v.origin, pev->origin, gpGlobals->v_forward ) >= m_flFieldOfView )
	if( m_flStopTalkTime > gpGlobals->time )
	if( gpGlobals->time > m_flLastSaidSmelled )
		m_flLastSaidSmelled = gpGlobals->time + 60;// don't talk about the stinky for a while.
	if( m_useTime > gpGlobals->time )
	g_VoiceGameMgr.Update(gpGlobals->frametime);
	time_remaining = (int)( flTimeLimit ? ( flTimeLimit - gpGlobals->time ) : 0 );
	if( flTimeLimit != 0 && gpGlobals->time >= flTimeLimit )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	for( int i = 1; i <= gpGlobals->maxClients; i++ )
	pev->nextthink = gpGlobals->time + 0.2;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals-> time + 0.1;
		if( gpGlobals->time - m_flPrevSoundTime < 0.5 )
			float dt = gpGlobals->time - m_flPrevSoundTime;
		m_flPrevSoundTime = gpGlobals->time;
		if( m_flSoundTime < gpGlobals->time )
		m_flSoundTime = gpGlobals->time + RANDOM_FLOAT( 5.0, 10.0 );
		else if( m_flSoundTime > gpGlobals->time )
			if( MyLevel() >= 0 && gpGlobals->time < m_flSoundTime )
				if( RANDOM_LONG( 0, 9 ) < m_flSoundTime - gpGlobals->time )
				if( m_flNextSong < gpGlobals->time )
					m_flNextSong = gpGlobals->time + RANDOM_FLOAT( 10, 20 );
				UTIL_TraceLine( vecSrc, vecSrc + gpGlobals->v_forward * 512, ignore_monsters, ENT( pev ), &tr1 );
				UTIL_TraceLine( vecSrc, vecSrc + gpGlobals->v_forward * 512, ignore_monsters, ENT( pev ), &tr2 );
	if( m_flPrevSoundTime + 2.0 > gpGlobals->time )
	else if( m_flPrevSoundTime + 5.0 > gpGlobals->time )
		pev->framerate = m_iDir + m_iDir * ( 5 - ( gpGlobals->time - m_flPrevSoundTime ) ) / 2 + m_flFramerateAdj;
	pev->nextthink = gpGlobals-> time + 0.1;
			gpGlobals->force_retouch++;
		//pev->nextthink = gpGlobals-> time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	if( m_flHitTime > gpGlobals->time )
	m_flHitTime = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.1;
	time = gpGlobals->time - m_startTime;
	m_startTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 1.0;
	pev->nextthink = gpGlobals->time + 0.5;
		pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.0, 0.5 );
	pev->nextthink = gpGlobals->time + 0.25;
		gpGlobals->force_retouch++;
		if( pev->dmgtime > gpGlobals->time )
			if( gpGlobals->time != pev->pain_finished )
		if( pev->dmgtime > gpGlobals->time && gpGlobals->time != pev->pain_finished )
	pev->pain_finished = gpGlobals->time;
	pev->dmgtime = gpGlobals->time + 0.5;// half second delay until this trigger can hurt toucher again
			if( DotProduct( gpGlobals->v_forward, pev->movedir ) < 0 )
	if( pev->nextthink > gpGlobals->time )
		gpGlobals->found_secrets++;
		pev->nextthink = gpGlobals->time + m_flWait;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + m_flDelay;
	if( gpGlobals->time == pev->dmgtime )
	pev->dmgtime = gpGlobals->time;
		gpGlobals->vecLandmarkOffset = VARS( pentLandmark )->origin;
	if( gpGlobals->pSaveData && ( (SAVERESTOREDATA *)gpGlobals->pSaveData)->pTable )
		CSave saveHelper( (SAVERESTOREDATA *)gpGlobals->pSaveData );
		gpGlobals->mapname = ALLOC_STRING( "start" );
	if( pChange->pev->nextthink < gpGlobals->time )
		pChange->pev->nextthink = gpGlobals->time + 0.1;
	if( FStrEq( STRING( gpGlobals->mapname ), "c2a5" ) && pev->spawnflags & 4 )
		m_flReturnTime = gpGlobals->time;
	m_flReturnTime = gpGlobals->time + m_flWait;
	m_flStopTime = gpGlobals->time;
	pev->nextthink = gpGlobals->time;
	if( m_hTarget == NULL || m_flReturnTime < gpGlobals->time )
	pev->avelocity.x = dx * 40 * gpGlobals->frametime;
	pev->avelocity.y = dy * 40 * gpGlobals->frametime;
	pev->nextthink = gpGlobals->time;
	m_moveDistance -= pev->speed * gpGlobals->frametime;
			m_flStopTime = gpGlobals->time + m_pentPath->GetDelay();
	if( m_flStopTime > gpGlobals->time )
		pev->speed = UTIL_Approach( 0, pev->speed, m_deceleration * gpGlobals->frametime );
		pev->speed = UTIL_Approach( m_targetSpeed, pev->speed, m_acceleration * gpGlobals->frametime );
	float fraction = 2 * gpGlobals->frametime;
		m_flPowerUp = gpGlobals->time + 1.0;
		m_flPowerUp = gpGlobals->time + 2.5;
	pev->nextthink = gpGlobals->time + 0.2;
	m_vecDir = gpGlobals->v_forward;
	pev->nextthink = gpGlobals->time + 1.0;
			pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time > m_flPowerUp )
	pev->nextthink = gpGlobals->time + 0.1;
	// ALERT( at_console, "serverflags %f\n", gpGlobals->serverflags );
	pev->nextthink = gpGlobals->time + 0.1;
	gpGlobals->trace_flags = FTRACE_SIMPLEBOX;
	pev->nextthink = gpGlobals->time + 0.1;
	if( gpGlobals->time < m_flPowerUp && flDamage < pev->health )
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.1, 0.3 );
		pev->nextthink = gpGlobals->time + 0.1;
	Vector vecAiming = gpGlobals->v_forward;
	pev->nextthink		= gpGlobals->time + 1;
	pev->nextthink = gpGlobals->time + 0.3; 
	pev->nextthink = gpGlobals->time + 0.3; 
		m_flLastSight = gpGlobals->time + m_flMaxWait;
		pev->nextthink = gpGlobals->time + .1;
		pev->nextthink = gpGlobals->time + 0.1;
		pev->nextthink = gpGlobals->time + 0.1; // turn on delay
		m_flPingTime = gpGlobals->time + 1;
	else if( m_flPingTime <= gpGlobals->time )
		m_flPingTime = gpGlobals->time + 1;
	pev->nextthink = gpGlobals->time + 0.1;
		m_flLastSight = gpGlobals->time + m_flMaxWait;
			m_flLastSight = gpGlobals->time + 0.5; // continue-shooting timeout
			if( gpGlobals->time > m_flLastSight )
				m_flLastSight = gpGlobals->time + m_flMaxWait;
			m_flLastSight = gpGlobals->time + 0.5;
			if( gpGlobals->time > m_flLastSight )
				m_flLastSight = gpGlobals->time + m_flMaxWait;
		gpGlobals->v_forward.x, gpGlobals->v_forward.y, gpGlobals->v_forward.z );
	if( DotProduct( vecLOS, gpGlobals->v_forward ) <= 0.866 ) // 30 degree slop
		Shoot( vecSrc, gpGlobals->v_forward );
	pev->nextthink = gpGlobals->time + 0.1;
	m_flLastSight = gpGlobals->time + m_flMaxWait;
	pev->nextthink = gpGlobals->time + 0.1;
				pev->nextthink = gpGlobals->time + .1;
	pev->nextthink = gpGlobals->time + 0.1;
			pev->nextthink = gpGlobals->time + 1.0; // spinup delay
			pev->nextthink = gpGlobals->time + 0.1; // retarget delay
	pev->nextthink = gpGlobals->time + 0.1;
		m_flSpinUpTime = gpGlobals->time + m_flMaxSpin;
 		if( gpGlobals->time > m_flLastSight )
		else if( ( m_flSpinUpTime ) && ( gpGlobals->time > m_flSpinUpTime ) )
	pev->nextthink = gpGlobals->time + 0.3;
	pev->nextthink = gpGlobals->time + 0.1;
	if( pev->dmgtime + RANDOM_FLOAT( 0, 2 ) > gpGlobals->time )
	if( pev->dmgtime + RANDOM_FLOAT( 0, 5 ) > gpGlobals->time )
	if( m_fSequenceFinished && !MoveTurret() && pev->dmgtime + 5 < gpGlobals->time )
		if( pev->dmgtime != gpGlobals->time || (RANDOM_LONG( 0, 10 ) < 1 ) )
			pev->dmgtime = gpGlobals->time;
		pev->dmgtime = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.3; 
		pev->nextthink = gpGlobals->time + 0.1;
		pev->dmgtime = gpGlobals->time;
		pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	if( pev->dmgtime + RANDOM_FLOAT( 0, 2 ) > gpGlobals->time )
	if( pev->dmgtime + RANDOM_FLOAT( 0, 8 ) > gpGlobals->time )
	if( m_fSequenceFinished && pev->dmgtime + 5 < gpGlobals->time )
	return gpGlobals->time;
	UTIL_TraceLine( pev->startpos, pev->startpos + gpGlobals->v_forward * 8192, ignore_monsters, owner, &tr );
	pev->starttime = gpGlobals->time;
	pev->impacttime = gpGlobals->time + travelTime;
	for( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )
	for( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )
	if( playerIndex > 0 && playerIndex <= gpGlobals->maxClients )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	for( i = 1; i <= gpGlobals->maxClients; i++ )
	tr.fAllSolid		= gpGlobals->trace_allsolid;
	tr.fStartSolid		= gpGlobals->trace_startsolid;
	tr.fInOpen		= gpGlobals->trace_inopen;
	tr.fInWater		= gpGlobals->trace_inwater;
	tr.flFraction		= gpGlobals->trace_fraction;
	tr.flPlaneDist		= gpGlobals->trace_plane_dist;
	tr.pHit			= gpGlobals->trace_ent;
	tr.vecEndPos		= gpGlobals->trace_endpos;
	tr.vecPlaneNormal	= gpGlobals->trace_plane_normal;
	tr.iHitgroup		= gpGlobals->trace_hitgroup;
#define STRING(offset)		(const char *)(gpGlobals->pStringBase + (int)offset)
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + time;
	if( ( m_pPlayer->pev->button & IN_ATTACK2 ) && CanAttack( m_flNextSecondaryAttack, gpGlobals->time, UseDecrement() ) )
	else if( ( m_pPlayer->pev->button & IN_ATTACK ) && CanAttack( m_flNextPrimaryAttack, gpGlobals->time, UseDecrement() ) )
		if( !IsUseable() && m_flNextPrimaryAttack < ( UseDecrement() ? 0.0 : gpGlobals->time ) ) 
				m_flNextPrimaryAttack = ( UseDecrement() ? 0.0 : gpGlobals->time ) + 0.3;
			if( m_iClip == 0 && !(iFlags() & ITEM_FLAG_NOAUTORELOAD ) && m_flNextPrimaryAttack < ( UseDecrement() ? 0.0 : gpGlobals->time ) )
	pev->nextthink = gpGlobals->time + .1;
	pev->nextthink = gpGlobals->time + .1;
	pev->nextthink = gpGlobals->time + .1;
			pev->nextthink = gpGlobals->time + .1;
		pev->nextthink = gpGlobals->time + .1;
			pWeapon->pev->nextthink = gpGlobals->time + 0.1;
	if( pev->skin < 0 || ( gpGlobals->deathmatch && FBitSet( pev->spawnflags, SF_DECAL_NOTINDEATHMATCH ) ) )
		pev->nextthink = gpGlobals->time;
	pev->nextthink = gpGlobals->time + 0.1;
	if( !WorldGraph.CheckNODFile( ( char * )STRING( gpGlobals->mapname ) ) )
		if( !WorldGraph.FLoadGraph ( (char *)STRING( gpGlobals->mapname ) ) )
			pEntity->pev->nextthink = gpGlobals->time + 0.3;
		gpGlobals->cdAudioTrack = atoi( pkvd->szValue );
		if( thinktime <= 0.0f || thinktime > PHYSICS_TIME() + gpGlobals->frametime )
		gpGlobals->time = thinktime;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
		if( gpGlobals->time > pev->dmgtime )
		pev->dmgtime = gpGlobals->time + XEN_PLANT_HIDE_TIME;
	pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.1, 0.4 );	// Load balance these a bit
	pev->nextthink = gpGlobals->time + 0.5;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + 0.1;
	pev->nextthink = gpGlobals->time + RANDOM_FLOAT( 0.1, 0.4 );	// Load balance these a bit
	pev->nextthink = gpGlobals->time + 0.1;
					pHurt->pev->velocity = pHurt->pev->velocity - gpGlobals->v_right * 100;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_right * 100;
					pHurt->pev->velocity = pHurt->pev->velocity + gpGlobals->v_forward * -100;
		if( m_flNextFlinch >= gpGlobals->time )
		if( m_flNextFlinch < gpGlobals->time )
			m_flNextFlinch = gpGlobals->time + ZOMBIE_FLINCH_DELAY;
